<!DOCTYPE html><html lang="en"><head><style>:root {
    --bg-dark: #1a1a1a;
    --bg-darker: #111111;
    --bg-light: #2d2d2d;
    --bg-lighter: #3c3c3c;
    --accent: #3b82f6;
    --accent-hover: #2563eb;
    --text-main: #e5e5e5;
    --text-muted: #a3a3a3;
    --border: #404040;
    --success: #10b981;
    --error: #ef4444;
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    scrollbar-width: thin;
    scrollbar-color: var(--bg-light) var(--bg-darker);
}

body {
    font-family: 'Segoe UI', system-ui, sans-serif;
    background-color: var(--bg-dark);
    color: var(--text-main);
    height: 100vh;
    overflow: hidden;
}

.app-container { display: flex; height: 100%; }

/* Sidebar */
.sidebar {
    width: 260px;
    background-color: var(--bg-darker);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    padding: 1rem;
    transition: width 0.3s ease;
}

.sidebar-header {
    display: flex;
    align-items: center;
    gap: 0.8rem;
    padding-bottom: 1.5rem;
    color: var(--accent);
    font-size: 1.2rem;
}

.search-container {
    position: relative;
    margin-bottom: 1rem;
}
.search-container > i {
    position: absolute;
    left: 12px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--text-muted);
}
#liveSearchInput {
    width: 100%;
    background: var(--bg-light);
    border: 1px solid var(--border);
    color: var(--text-main);
    border-radius: 6px;
    padding: 0.6rem 0.6rem 0.6rem 2.5rem;
    font-size: 0.9rem;
    outline: none;
}
#liveSearchInput:focus { border-color: var(--accent); }

.search-results {
    display: none;
    position: absolute;
    top: 105%;
    left: 0;
    right: 0;
    background: var(--bg-lighter);
    border: 1px solid var(--border);
    border-radius: 6px;
    max-height: 400px;
    overflow-y: auto;
    z-index: 1000;
}
.search-result-item {
    padding: 0.8rem 1rem;
    cursor: pointer;
    border-bottom: 1px solid var(--border);
    font-size: 0.9rem;
}
.search-result-item:last-child { border-bottom: none; }
.search-result-item:hover { background-color: var(--accent); color: white; }
.search-result-item small { color: var(--text-muted); display: block; margin-top: 4px; }
.search-result-item:hover small { color: #eee; }

.sidebar-nav { flex: 1; display: flex; flex-direction: column; gap: 0.5rem; }
.nav-btn {
    background: none; border: none; color: var(--text-muted); padding: 0.8rem 1rem;
    text-align: left; cursor: pointer; border-radius: 6px; font-size: 0.95rem;
    transition: all 0.2s; display: flex; align-items: center; gap: 12px;
}
.nav-btn:hover { background-color: var(--bg-light); color: var(--text-main); }
.nav-btn.active { background-color: var(--accent); color: white; }

.sidebar-footer { padding-top: 1rem; }
.connection-status { font-size: 0.8rem; color: var(--text-muted); display: flex; align-items: center; gap: 8px; }
.indicator { width: 8px; height: 8px; border-radius: 50%; background-color: var(--error); }
.indicator.connected { background-color: var(--success); }

/* Main Content */
.main-content { flex: 1; position: relative; overflow: hidden; background-color: var(--bg-dark); }
.view { display: none; height: 100%; flex-direction: column; padding: 1.5rem; overflow-y: auto; }
.view.active { display: flex; }

/* Chat View */
#view-chat { padding: 0; flex-direction: row; }
.chat-layout { display: flex; width: 100%; height: 100%; }
.chat-drawer {
    width: 280px; background: var(--bg-darker); border-right: 1px solid var(--border);
    display: flex; flex-direction: column; transition: width 0.3s ease;
}
.drawer-header { padding: 1rem; border-bottom: 1px solid var(--border); }
.new-chat-btn {
    width: 100%; background: var(--accent); color: white; border: none; padding: 0.7rem;
    border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; font-size: 0.95rem;
}
.chat-list-tabs { display: flex; border-bottom: 1px solid var(--border); }
.chat-list-tabs button { flex: 1; background: transparent; border: none; color: var(--text-muted); padding: 8px; cursor: pointer; }
.chat-list-tabs button.active { color: var(--accent); border-bottom: 2px solid var(--accent); }
.chat-list { flex: 1; overflow-y: auto; padding: 0.5rem; }
.chat-item { padding: 0.8rem; border-radius: 6px; cursor: pointer; margin-bottom: 4px; color: var(--text-muted); font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; justify-content: space-between; align-items: center; }
.chat-item:hover { background: var(--bg-light); color: var(--text-main); }
.chat-item.active { background: var(--bg-light); color: var(--text-main); border-left: 3px solid var(--accent); }
.chat-item .item-actions { display: none; gap: 8px; }
.chat-item:hover .item-actions { display: flex; }
.drawer-actions { padding: 0.8rem; border-top: 1px solid var(--border); display: flex; justify-content: space-around; }
.drawer-actions button { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 1rem; }
.drawer-actions button:hover { color: var(--accent); }

.chat-interface { flex: 1; display: flex; flex-direction: column; height: 100%; position: relative; }
.chat-header { display: flex; justify-content: space-between; align-items: center; padding: 0.8rem 1.5rem; border-bottom: 1px solid var(--border); background: var(--bg-dark); }
.model-selector-group { display: flex; gap: 10px; align-items: center; }
.selector-item { display: flex; align-items: center; gap: 5px; color: var(--text-muted); }
select { background: var(--bg-light); color: var(--text-main); border: 1px solid var(--border); padding: 0.5rem; border-radius: 6px; min-width: 160px; }
.refresh-btn, .toggle-btn, .action-btn { background: var(--bg-light); border: 1px solid var(--border); color: var(--text-main); width: 38px; height: 38px; border-radius: 6px; cursor: pointer; transition: 0.2s; display: inline-flex; align-items: center; justify-content: center; }
.chat-controls { display: flex; gap: 8px; }
.toggle-btn.active { background: var(--accent); color: white; border-color: var(--accent); }
.chat-history { flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 1.5rem; padding: 1.5rem; scroll-behavior: smooth; }

/* Improved Conversational UI */
.message {
    display: flex;
    gap: 1rem;
    max-width: 85%;
    width: fit-content;
    margin: 0.5rem 0;
    position: relative;
}

.message.user {
    align-self: flex-end;
    flex-direction: row-reverse;
}

.message.ai {
    align-self: flex-start;
}

.message.user .content {
    background-color: var(--accent);
    color: white;
    border-top-right-radius: 2px;
}

.message.ai .content {
    background-color: var(--bg-light);
    border-top-left-radius: 2px;
}

.message .content {
    padding: 0.8rem 1.2rem;
    border-radius: 12px;
    line-height: 1.6;
    min-width: 0;
    white-space: pre-wrap;
    word-break: break-word;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.message .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--bg-lighter);
    color: var(--text-muted);
    flex-shrink: 0;
    border: 1px solid var(--border);
    font-size: 0.9rem;
}
.message.user .avatar {
    background: var(--accent);
    color: white;
    border: none;
}

.message-tools { position: absolute; bottom: -25px; left: 10px; font-size: 0.75rem; color: var(--text-muted); display: flex; gap: 8px; align-items: center; opacity: 0; transition: opacity 0.2s; pointer-events: none; }
.message:hover .message-tools { opacity: 1; pointer-events: auto; }
.version-nav { display: flex; align-items: center; gap: 4px; background: var(--bg-light); padding: 2px 6px; border-radius: 4px; border: 1px solid var(--border); }
.version-nav button, .message-tools button { background: none; border: none; color: var(--text-main); cursor: pointer; font-size: 0.8rem; }

.image-attachment-container {
    display: flex;
    gap: 8px;
    margin-top: 10px;
    flex-wrap: wrap;
}
.image-attachment-container img {
    max-width: 150px;
    max-height: 150px;
    border-radius: 8px;
    object-fit: cover;
    border: 1px solid var(--border);
}

/* Markdown & Citations */
.content pre { background: #000; padding: 1rem; border-radius: 6px; overflow-x: auto; margin: 0.5rem 0; font-size: 0.9em; }
.content code { font-family: 'Fira Code', monospace; background: rgba(0,0,0,0.3); padding: 2px 5px; border-radius: 4px; }
.citation { display: inline-block; font-size: 0.7rem; color: var(--accent); cursor: pointer; margin: 0 2px; text-decoration: none; background: rgba(59, 130, 246, 0.15); padding: 2px 6px; border-radius: 10px; border: 1px solid rgba(59, 130, 246, 0.3); transition: background 0.2s; }
.citation:hover { background: rgba(59, 130, 246, 0.3); }

.chat-input-area { max-width: 850px; width: 100%; margin: 0 auto; position: relative; padding: 1rem 1.5rem; }
.input-wrapper { background: var(--bg-light); border: 1px solid var(--border); border-radius: 12px; padding: 0.5rem; display: flex; align-items: flex-end; transition: border-color 0.2s; }
.input-wrapper:focus-within { border-color: var(--accent); }
textarea { flex: 1; background: transparent; border: none; color: var(--text-main); resize: none; outline: none; font-size: 1rem; padding: 0.5rem; max-height: 200px; }
.input-actions { display: flex; gap: 0.2rem; margin-bottom: 0.2rem; }
.input-actions button { background: transparent; border: none; color: var(--text-muted); cursor: pointer; padding: 8px; border-radius: 6px; width: 38px; height: 38px; font-size: 1.1rem; }
.input-actions button:hover { color: var(--accent); background-color: var(--bg-dark); }
#sendBtn { background-color: var(--accent); color: white; }
#sendBtn:hover { background-color: var(--accent-hover); }
#voiceBtn.listening { color: var(--error); animation: pulse 1.5s infinite; }
@keyframes pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.2); opacity: 0.7; } }

/* Generic & Section Styles */
.section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem; }
.primary-btn { background: var(--accent); color: white; padding: 0.7rem 1.3rem; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; display: inline-flex; align-items: center; gap: 8px; transition: background 0.2s; }
.primary-btn:hover { background: var(--accent-hover); }
.stats-panel { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem; }
.stat-card { background: var(--bg-light); padding: 1.5rem; border-radius: 8px; border: 1px solid var(--border); }
.stat-card h3 { color: var(--text-muted); font-size: 0.9rem; margin-bottom: 0.5rem; }
.stat-card span { font-size: 1.8rem; font-weight: bold; }
.stat-card.warning button { background: rgba(239, 68, 68, 0.2); color: var(--error); border: 1px solid var(--error); padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer; width: 100%; }
.document-list table { width: 100%; border-collapse: collapse; }
.document-list th { text-align: left; color: var(--text-muted); padding: 1rem; border-bottom: 1px solid var(--border); }
.document-list td { padding: 1rem; border-bottom: 1px solid var(--border); }
.delete-doc-btn { color: var(--error); background: none; border: none; cursor: pointer; }
.progress-bar-container { margin-top: 1rem; background: var(--bg-light); padding: 1rem; border-radius: 8px; }
.progress-bar { height: 6px; background: var(--bg-dark); border-radius: 3px; margin-top: 5px; overflow: hidden; }
.progress-bar .fill { height: 100%; background: var(--accent); width: 0%; transition: width 0.3s; }

/* Settings */
.settings-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 1.5rem; }
.setting-card { background: var(--bg-light); padding: 1.5rem; border-radius: 8px; border: 1px solid var(--border); display: flex; flex-direction: column; gap: 10px; }
.setting-card input, .setting-card textarea, .setting-card select { background: var(--bg-dark); border: 1px solid var(--border); color: var(--text-main); padding: 0.6rem; border-radius: 4px; }
.save-area { margin-top: 2rem; text-align: right; }

/* Workspace / Collections */
.collections-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1.5rem; }
.collection-card {
    background: var(--bg-light); border: 1px solid var(--border); border-radius: 8px; padding: 1.2rem;
    display: flex; flex-direction: column; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
}
.collection-card:hover { transform: translateY(-5px); box-shadow: 0 10px 20px rgba(0,0,0,0.3); }
.collection-card h3 { margin-bottom: 0.5rem; color: var(--text-main); }
.collection-card p { flex: 1; font-size: 0.9rem; color: var(--text-muted); line-height: 1.5; }
.collection-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 1rem; font-size: 0.8rem; color: var(--text-muted); }
.collection-footer button { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 1rem; }
.collection-footer button:hover { color: var(--error); }

/* Call Overlay */
.call-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); backdrop-filter: blur(10px); z-index: 2000; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; }
.call-content { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; gap: 20px; position: relative; }
.call-avatar-container { position: relative; width: 150px; height: 150px; }
.call-avatar { width: 100%; height: 100%; border-radius: 50%; background: var(--bg-light); border: 3px solid var(--accent); display: flex; align-items: center; justify-content: center; font-size: 4rem; position: relative; z-index: 2; }
.visualizer { position: absolute; top: -10px; left: -10px; right: -10px; bottom: -10px; border-radius: 50%; border: 2px solid var(--accent); opacity: 0; transition: 0.2s; }
.visualizer.active { animation: pulse-ring 2s infinite; }
@keyframes pulse-ring { 0% { transform: scale(1); opacity: 0.6; } 100% { transform: scale(1.5); opacity: 0; } }
.call-controls { padding: 2rem; display: flex; gap: 20px; width: 100%; justify-content: center; }
.control-btn { width: 60px; height: 60px; border-radius: 50%; border: none; background: var(--bg-light); color: white; font-size: 1.5rem; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: 0.2s; }
.control-btn.hangup { background: var(--error); }
.control-btn:hover { transform: scale(1.1); }
#localVideo { position: absolute; bottom: 20px; right: 20px; width: 150px; border-radius: 12px; border: 2px solid var(--border); z-index: 3; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
.live-transcript { font-size: 1.2rem; text-align: center; max-width: 80%; opacity: 0.8; min-height: 1.5em; }

/* Responsive */
@media (max-width: 1024px) {
    .chat-drawer { width: 240px; }
}
@media (max-width: 768px) {
    .sidebar { position: fixed; z-index: 100; transform: translateX(-100%); transition: transform 0.3s; height: 100%; box-shadow: 5px 0 15px rgba(0,0,0,0.2); }
    .sidebar.open { transform: translateX(0); }
    .chat-drawer { width: 70px; }
    .chat-drawer .new-chat-btn span, .chat-item span, .chat-list-tabs { display: none; }
    .new-chat-btn { font-size: 1.2rem; }
}</style></head><body><!-- Font Awesome, KaTeX, Marked, DOMPurify, PDF.js, jsPDF, Mammoth CDNs -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
<script>
    if (typeof pdfjsLib !== 'undefined') {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }
</script>

<div class="app-container">
    <!-- Sidebar -->
    <aside class="sidebar">
        <div class="sidebar-header">
            <i class="fa-solid fa-brain"></i>
            <h2>Shinzo UI</h2>
        </div>

        <div class="search-container">
            <i class="fa-solid fa-magnifying-glass"></i>
            <input type="text" id="liveSearchInput" placeholder="Search... (prefix with 'web:')">
            <div class="search-results" id="searchResults"></div>
        </div>

        <nav class="sidebar-nav">
            <button class="nav-btn active" onclick="app.switchTab('chat')">
                <i class="fa-solid fa-comments"></i> Chat
            </button>
            <button class="nav-btn" onclick="app.switchTab('knowledge')">
                <i class="fa-solid fa-book-open"></i> Knowledge
            </button>
            <button class="nav-btn" onclick="app.switchTab('workspace')">
                <i class="fa-solid fa-rocket"></i> Spaces
            </button>
            <button class="nav-btn" onclick="app.switchTab('models')">
                <i class="fa-solid fa-cubes"></i> Model Builder
            </button>
            <button class="nav-btn" onclick="app.switchTab('settings')">
                <i class="fa-solid fa-sliders"></i> Settings
            </button>
        </nav>

        <div class="sidebar-footer">
            <div class="connection-status" id="connectionStatus">
                <span class="indicator"></span> <span id="statusText">Checking...</span>
            </div>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
        
        <!-- View: Chat -->
        <section id="view-chat" class="view active">
            <div class="chat-layout">
                <!-- Chat History Sidebar -->
                <div class="chat-drawer">
                    <div class="drawer-header">
                        <button class="new-chat-btn" onclick="app.newChat()">
                            <i class="fa-solid fa-plus"></i> <span>New Chat</span>
                        </button>
                    </div>
                    <div class="chat-list-tabs">
                        <button class="active" onclick="app.filterChatList('active')">Active</button>
                        <button onclick="app.filterChatList('archived')">Archived</button>
                    </div>
                    <div class="chat-list" id="chatList">
                        <!-- Chat items injected here -->
                    </div>
                    <div class="drawer-actions">
                        <button onclick="app.archiveAllChats()" title="Archive All Chats"><i class="fa-solid fa-box-archive"></i></button>
                        <button onclick="app.exportChats()" title="Export All Chats (JSON)"><i class="fa-solid fa-file-export"></i></button>
                        <button onclick="app.triggerImport()" title="Import Chats"><i class="fa-solid fa-file-import"></i></button>
                        <input type="file" id="importChatInput" hidden accept=".json" onchange="app.importChats(this)">
                        <button onclick="app.deleteAllChats()" title="Delete All Chats"><i class="fa-solid fa-trash-can"></i></button>
                    </div>
                </div>

                <!-- Actual Chat Interface -->
                <div class="chat-interface">
                    <div class="chat-header">
                        <div class="model-selector-group">
                            <!-- Active Space Indicator -->
                            <div id="activeSpaceIndicator" style="display:none"></div>

                            <div class="selector-item">
                                <i class="fa-solid fa-robot"></i>
                                <select id="modelSelect">
                                    <option value="" disabled selected>Primary Model</option>
                                </select>
                            </div>
                            <div class="selector-item concurrent-opt" style="display:none">
                                <i class="fa-solid fa-people-arrows"></i>
                                <select id="modelSelect2">
                                    <option value="" selected>No Secondary</option>
                                </select>
                            </div>
                            <button class="refresh-btn" onclick="app.fetchModels()" title="Refresh Models"><i class="fa-solid fa-rotate"></i></button>
                        </div>
                        <center><p>Made with ðŸ’– by <a href="https://github.com/one-man-studios" style="color: #3b82f6; text-decoration: none;">One Man Studios.</a></p></center>
                        <div class="chat-controls">
                            <button class="action-btn" onclick="app.voice.startCall('voice')" title="Voice Call"><i class="fa-solid fa-phone-volume"></i></button>
                            <button class="action-btn" onclick="app.voice.startCall('video')" title="Video Call"><i class="fa-solid fa-video"></i></button>
                            <button class="action-btn" onclick="app.archiveCurrentChat" title="Archive Chat"><i class="fa-solid fa-box-archive"></i></button>
                            <button class="action-btn" onclick="app.downloadChat()" title="Download Chat"><i class="fa-solid fa-download"></i></button>
                            <button class="toggle-btn" id="concurrentToggle" onclick="app.toggleConcurrent()" title="Toggle Concurrent Models"><i class="fa-solid fa-clone"></i></button>
                            <button id="webSearchToggle" class="toggle-btn" onclick="app.toggleWebSearch()" title="Toggle Web Search"><i class="fa-solid fa-globe"></i></button>
                        </div>
                    </div>

                    <div id="chatHistory" class="chat-history">
                        <div class="message system">
                            <div class="content">
                                <p>ðŸ‘‹ Welcome to <strong>Shinzo UI</strong>. Start a conversation or use the search bar to find information.</p>
                            </div>
                        </div>
                    </div>

                    <div class="chat-input-area">
                        <div id="suggestionBox" class="suggestion-box" style="display:none"></div>
                        <div class="input-wrapper">
                            <textarea id="userInput" placeholder="Type a message... (Enter to send, Shift+Enter for new line)" rows="1"></textarea>
                            <div class="input-actions">
                                <button id="attachBtn" onclick="document.getElementById('fileInput').click()" title="Attach File"><i class="fa-solid fa-paperclip"></i></button>
                                <input type="file" id="fileInput" style="display: none" onchange="app.handleFileAttach(this)" accept="image/*">
                                <button id="voiceBtn" onclick="app.toggleVoice()" title="Quick Voice Note"><i class="fa-solid fa-microphone"></i></button>
                                <button id="sendBtn" onclick="app.sendMessage()" title="Send (Enter)"><i class="fa-solid fa-paper-plane"></i></button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- View: Knowledge Base -->
        <section id="view-knowledge" class="view">
            <div class="section-header">
                <h2>Global Knowledge Base</h2>
                <label for="fileUpload" class="primary-btn">
                    <i class="fa-solid fa-upload"></i> Upload Documents
                </label>
                <input type="file" id="fileUpload" multiple accept=".txt,.md,.pdf,.csv,.json,.m4a,.mp3,.wav,.docx" style="display:none" onchange="app.handleFileUpload(this)">
            </div>

            <div class="stats-panel">
                <div class="stat-card"><h3>Documents</h3><span id="docCount">0</span></div>
                <div class="stat-card"><h3>Vectors</h3><span id="vectorCount">0</span></div>
                <div class="stat-card"><h3>DB Type</h3><span id="dbTypeDisplay" style="font-size: 1.2rem; color: var(--accent);">IndexedDB</span></div>
                <div class="stat-card warning"><button onclick="app.clearDatabase()">Reset Database</button></div>
            </div>

            <div class="document-list">
                <table>
                    <thead><tr><th>Name</th><th>Type</th><th>Chunks</th><th>Action</th></tr></thead>
                    <tbody id="docTableBody"></tbody>
                </table>
            </div>
            
            <div id="uploadProgress" class="progress-bar-container" style="display:none">
                <span id="uploadStatusText">Processing...</span>
                <div class="progress-bar"><div class="fill"></div></div>
            </div>
        </section>

        <!-- View: Workspace (Spaces) -->
        <section id="view-workspace" class="view">
            <div class="section-header">
                <h2>Spaces (Project Workspaces)</h2>
                <button class="primary-btn" onclick="app.openSpaceModal()">
                    <i class="fa-solid fa-plus"></i> Create Space
                </button>
            </div>
            <p style="color: var(--text-muted); margin-bottom: 2rem;">Spaces allow you to containerize knowledge, set custom instructions, and organize specific projects.</p>
            <div class="collections-grid" id="spacesGrid"></div>
        </section>

        <!-- View: Single Space Detail -->
        <section id="view-space" class="view">
            <div class="section-header">
                <div style="display:flex; align-items:center; gap:10px">
                    <button class="action-btn" onclick="app.switchTab('workspace')"><i class="fa-solid fa-arrow-left"></i></button>
                    <h2 id="spaceTitleDisplay">Space Name</h2>
                </div>
                <div style="display:flex; gap:10px">
                    <button class="primary-btn" onclick="app.newChatInSpace()"><i class="fa-solid fa-comment-medical"></i> New Space Chat</button>
                    <button class="action-btn" onclick="app.deleteCurrentSpace()" style="color:var(--error); border-color:var(--error)"><i class="fa-solid fa-trash"></i></button>
                </div>
            </div>
            
            <div class="settings-grid">
                <div class="setting-card" style="grid-column: span 2">
                    <h3>Instructions / System Prompt</h3>
                    <p style="font-size:0.8rem; color:var(--text-muted)">Define how the model should behave within this space.</p>
                    <textarea id="spaceInstructions" rows="4" onchange="app.updateSpaceConfig()"></textarea>
                </div>
                
                <div class="setting-card">
                    <h3>Knowledge & Files</h3>
                    <label class="primary-btn" style="font-size:0.8rem; width:fit-content">
                        <i class="fa-solid fa-plus"></i> Add Files
                        <input type="file" multiple hidden onchange="app.handleSpaceFileUpload(this)">
                    </label>
                    <div id="spaceFileList" class="document-list" style="margin-top:10px; max-height:200px; overflow-y:auto"></div>
                </div>

                <div class="setting-card">
                    <h3>External Links</h3>
                    <div style="display:flex; gap:5px; margin-bottom:10px">
                        <input type="text" id="newSpaceLink" placeholder="https://...">
                        <button class="action-btn" onclick="app.addLinkToSpace()"><i class="fa-solid fa-plus"></i></button>
                    </div>
                    <div id="spaceLinkList" class="document-list"></div>
                </div>

                <div class="setting-card" style="grid-column: span 2">
                    <h3>Space Chats</h3>
                    <div id="spaceChatList" class="chat-list" style="max-height: 200px; overflow-y: auto;"></div>
                </div>
            </div>
        </section>

        <!-- View: Model Builder -->
        <section id="view-models" class="view">
            <div class="section-header">
                <h2>Model Builder (Modelfile)</h2>
            </div>
            <div class="settings-grid">
                <div class="setting-card">
                    <label>New Model Name</label>
                    <input type="text" id="builderName" placeholder="e.g., my-assistant-v1">
                </div>
                <div class="setting-card">
                    <label>Base Model</label>
                    <select id="builderBaseModel"></select>
                </div>
                <div class="setting-card" style="grid-column: span 2">
                    <label>System Prompt</label>
                    <textarea id="builderPrompt" rows="5" placeholder="You are Mario from Super Mario Bros..."></textarea>
                </div>
                <div class="setting-card" style="grid-column: span 2">
                    <label>Parameters (Optional)</label>
                    <textarea id="builderParams" rows="3" placeholder="PARAMETER temperature 0.7"></textarea>
                </div>
            </div>
            <div class="save-area">
                <button class="primary-btn" onclick="app.buildModel()">Create Model</button>
            </div>
        </section>

        <!-- View: Settings -->
        <section id="view-settings" class="view">
            <div class="section-header">
                <h2>Settings</h2>
                <button class="primary-btn" onclick="app.saveSettings()">Save Settings</button>
            </div>
            
            <div class="settings-grid">
                <div class="setting-card">
                    <h3>Connection</h3>
                    <label>API URL</label>
                    <input type="text" id="apiUrl" placeholder="http://localhost:11434">
                    <label>API Key (Optional)</label>
                    <input type="password" id="apiKey">
                </div>

                <div class="setting-card">
                    <h3>RAG & Embeddings</h3>
                    <label>Provider</label>
                    <select id="embeddingProvider" onchange="app.toggleEmbeddingOptions()">
                        <option value="ollama">Ollama (Server)</option>
                        <option value="local">Local (Browser / Transformers.js)</option>
                        <option value="openai">OpenAI / External Compatible</option>
                    </select>
                    
                    <div id="embeddingModelGroup">
                        <label>Embedding Model</label>
                        <select id="embeddingModelSelect"></select>
                        <input type="text" id="embeddingModelInput" style="display:none" placeholder="e.g., text-embedding-3-small">
                    </div>

                    <div id="embeddingCustomConfig" style="display:none; margin-top:10px; border-top:1px solid var(--border); padding-top:10px;">
                        <label>API URL</label>
                        <input type="text" id="embeddingBaseUrl" placeholder="https://api.openai.com/v1/embeddings">
                        <label>API Key</label>
                        <input type="password" id="embeddingApiKey" placeholder="sk-...">
                    </div>

                    <label style="margin-top:10px">Chunk Size</label>
                    <input type="number" id="chunkSize" value="1000">
                    <label>Top K Results</label>
                    <input type="number" id="topK" value="3">
                </div>

                <div class="setting-card">
                    <h3>Web Search</h3>
                    <label>Serper API Key</label>
                    <input type="password" id="webSearchApiKey">
                    <label>Proxy Mode</label>
                    <select id="proxyMode">
                        <option value="cors">CORS Proxy</option>
                        <option value="custom">Custom Proxy</option>
                    </select>
                </div>

                <div class="setting-card">
                    <h3>Voice & Media</h3>
                    <label>STT Endpoint</label>
                    <input type="text" id="sttUrl" placeholder="/v1/audio/transcriptions">
                    <label>TTS Endpoint (Optional)</label>
                    <input type="text" id="ttsUrl" placeholder="/v1/audio/speech">
                    <label>Playback Speed: <span id="speedVal">1.0</span>x</label>
                    <input type="range" id="playbackSpeed" min="0.5" max="2.0" step="0.1" oninput="document.getElementById('speedVal').innerText=this.value">
                </div>

                <div class="setting-card">
                    <h3>Behavior</h3>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:5px">
                        <input type="checkbox" id="enableHistory" style="width:auto">
                        <label for="enableHistory">Save Chat History</label>
                    </div>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:5px">
                        <input type="checkbox" id="vadEnabled" style="width:auto">
                        <label for="vadEnabled">Voice Activity Detection (VAD)</label>
                    </div>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:5px">
                        <input type="checkbox" id="handsFree" style="width:auto">
                        <label for="handsFree">Hands-free Mode (Auto Reply TTS)</label>
                    </div>
                    <div style="display:flex; gap:10px; align-items:center">
                        <input type="checkbox" id="emojiCall" style="width:auto">
                        <label for="emojiCall">Emoji Mode (Calls)</label>
                    </div>
                </div>
            </div>
        </section>
    </main>
</div>

<!-- Modals & Overlays -->

<!-- Space Creation Modal -->
<div id="spaceModal" class="call-overlay" style="display:none; background:rgba(0,0,0,0.8);">
    <div class="setting-card" style="width: 400px; background: var(--bg-light);" onclick="event.stopPropagation()">
        <h3>Create New Space</h3>
        <label>Name</label>
        <input type="text" id="newSpaceTitle" placeholder="Project Alpha">
        <label>Description</label>
        <input type="text" id="newSpaceDesc" placeholder="Research notes for...">
        <label>Custom Instructions</label>
        <textarea id="newSpacePrompt" rows="3" placeholder="System prompt for this space..."></textarea>
        <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:15px">
            <button class="action-btn" onclick="document.getElementById('spaceModal').style.display='none'">Cancel</button>
            <button class="primary-btn" onclick="app.saveNewSpace()">Create</button>
        </div>
    </div>
</div>

<!-- Voice/Video Call Overlay -->
<div id="callOverlay" class="call-overlay" style="display:none">
    <div class="call-content">
        <div class="call-avatar-container">
            <div id="audioVisualizer" class="visualizer"></div>
            <div class="call-avatar"><i class="fa-solid fa-robot"></i></div>
        </div>
        <div id="callStatus" style="font-size: 1.5rem; font-weight: 300;">Connecting...</div>
        <div id="liveTranscript" class="live-transcript"></div>
    </div>
    
    <video id="localVideo" autoplay muted playsinline></video>
    
    <div class="call-controls">
        <button class="control-btn" id="muteBtn" onclick="app.voice.toggleMute()"><i class="fa-solid fa-microphone"></i></button>
        <button class="control-btn" onclick="app.voice.toggleVideo()"><i class="fa-solid fa-video"></i></button>
        <button class="control-btn hangup" onclick="app.voice.endCall()"><i class="fa-solid fa-phone-slash"></i></button>
    </div>
</div><script>/**
 * Super RAG - A fully functional, self-contained RAG application
 * Features: Live Search, Knowledge Base, Workspace (Spaces), Model Builder, Voice/Video Calls
 */

const DB_NAME = 'SuperRAG_DB';
const DB_VERSION = 5;

// --- 1. Storage Abstraction (Vector DB + Chat History + Spaces) ---
class VectorDB {
    constructor() {
        this.idb = null;
    }

    async init() {
        return new Promise((resolve, reject) => {
            // Fallback for environments where IndexedDB might be restricted
            if (!window.indexedDB) return reject("IndexedDB not supported");
            
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('documents')) db.createObjectStore('documents', { keyPath: 'id' });
                if (!db.objectStoreNames.contains('chunks')) {
                    const chunkStore = db.createObjectStore('chunks', { keyPath: 'id' });
                    chunkStore.createIndex('docId', 'docId', { unique: false });
                }
                if (!db.objectStoreNames.contains('conversations')) {
                    const chatStore = db.createObjectStore('conversations', { keyPath: 'id' });
                    chatStore.createIndex('updatedAt', 'updatedAt', { unique: false });
                }
                if (!db.objectStoreNames.contains('spaces')) {
                    const spaceStore = db.createObjectStore('spaces', { keyPath: 'id' });
                    spaceStore.createIndex('updatedAt', 'updatedAt', { unique: false });
                }
            };
            request.onsuccess = (e) => { this.idb = e.target.result; resolve(); };
            request.onerror = (e) => reject(`IndexedDB error: ${e.target.error}`);
        });
    }

    async addDocument(doc) { if (!this.idb) return; return this.idbTx('documents', 'readwrite', s => s.put(doc)); }
    async addChunks(chunks) { if (!this.idb) return; return this.idbTx('chunks', 'readwrite', s => chunks.forEach(c => s.put(c))); }
    async getAllDocuments() { if (!this.idb) return []; return this.idbTx('documents', 'readonly', s => s.getAll()); }
    async getVectorCount() { if (!this.idb) return 0; return this.idbTx('chunks', 'readonly', s => s.count()); }

    async saveChat(chat) { if (!this.idb) return; return this.idbTx('conversations', 'readwrite', s => s.put(chat)); }
    async getChats() {
        if (!this.idb) return [];
        const chats = await this.idbTx('conversations', 'readonly', s => s.getAll());
        return chats.sort((a,b) => b.updatedAt - a.updatedAt);
    }
    async deleteChat(id) { if (!this.idb) return; return this.idbTx('conversations', 'readwrite', s => s.delete(id)); }
    async deleteAllChats() { if (!this.idb) return; return this.idbTx('conversations', 'readwrite', s => s.clear()); }

    // Space Operations
    async saveSpace(space) { if (!this.idb) return; return this.idbTx('spaces', 'readwrite', s => s.put(space)); }
    async getSpaces() { if (!this.idb) return []; return this.idbTx('spaces', 'readonly', s => s.getAll()); }
    async getSpace(id) { if (!this.idb) return null; return this.idbTx('spaces', 'readonly', s => s.get(id)); }
    async deleteSpace(id) { if (!this.idb) return; return this.idbTx('spaces', 'readwrite', s => s.delete(id)); }

    async vectorSearch(queryVector, k, filterDocIds = null) {
        if (!this.idb) return [];
        let chunks = await this.idbTx('chunks', 'readonly', s => s.getAll());
        if (!chunks || chunks.length === 0) return [];
        
        if (filterDocIds && filterDocIds.length > 0) {
            chunks = chunks.filter(c => filterDocIds.includes(c.docId));
        }

        const scored = chunks.map(chunk => ({
            ...chunk,
            score: this.cosineSimilarity(queryVector, chunk.vector)
        }));
        scored.sort((a, b) => b.score - a.score);
        return scored.slice(0, k);
    }

    async clear() {
        if (!this.idb) return;
        await this.idbTx('documents', 'readwrite', s => s.clear());
        await this.idbTx('chunks', 'readwrite', s => s.clear());
        await this.idbTx('conversations', 'readwrite', s => s.clear());
        await this.idbTx('spaces', 'readwrite', s => s.clear());
    }

    async deleteDocument(docId) {
        if (!this.idb) return;
        await this.idbTx('documents', 'readwrite', s => s.delete(docId));
        const chunks = await this.idbTx('chunks', 'readonly', s => s.index('docId').getAll(docId));
        const tx = this.idb.transaction(['chunks'], 'readwrite');
        chunks.forEach(c => tx.objectStore('chunks').delete(c.id));
        return new Promise(r => tx.oncomplete = r);
    }

    idbTx(store, mode, cb) {
        if (!this.idb) return Promise.reject("Database not initialized");
        return new Promise((resolve, reject) => {
            const tx = this.idb.transaction(store, mode);
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
            const req = cb(tx.objectStore(store));
            if (req && req instanceof IDBRequest) {
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            }
        });
    }

    cosineSimilarity(vecA, vecB) {
        if (!vecA || !vecB) return 0;
        let dot = 0.0, normA = 0.0, normB = 0.0;
        for (let i = 0; i < vecA.length; i++) {
            dot += vecA[i] * vecB[i];
            normA += vecA[i] ** 2;
            normB += vecB[i] ** 2;
        }
        if (normA === 0 || normB === 0) return 0;
        return dot / (Math.sqrt(normA) * Math.sqrt(normB));
    }
}

// --- 2. Voice & Call Manager ---
class VoiceManager {
    constructor(app) {
        this.app = app;
        this.isCallActive = false; this.mode = 'voice'; this.stream = null; this.mediaRecorder = null;
        this.audioCtx = null; this.analyser = null; this.silenceTimer = null; this.isListening = false;
        this.isMuted = false; this.isSpeaking = false; this.interruptController = null;
        this.config = { vadThreshold: 0.02, silenceDuration: 2500, mimeType: 'audio/webm;codecs=opus' };
    }

    async startCall(mode) {
        if (this.isCallActive) return;
        this.mode = mode;
        this.isCallActive = true;
        document.getElementById('callOverlay').style.display = 'flex';
        document.getElementById('localVideo').style.display = mode === 'video' ? 'block' : 'none';
        
        try {
            this.stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: mode === 'video' });
            if (mode === 'video') document.getElementById('localVideo').srcObject = this.stream;
            this.initAudioContext();
            this.startListening();
        } catch (e) { alert(`Error accessing media devices: ${e.message}`); this.endCall(); }
    }

    endCall() {
        this.isCallActive = false;
        if (this.stream) this.stream.getTracks().forEach(t => t.stop());
        if (this.audioCtx) this.audioCtx.close();
        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') this.mediaRecorder.stop();
        document.getElementById('callOverlay').style.display = 'none';
        this.interrupt();
    }

    initAudioContext() {
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const source = this.audioCtx.createMediaStreamSource(this.stream);
        this.analyser = this.audioCtx.createAnalyser();
        source.connect(this.analyser);
        this.detectSilence();
    }

    detectSilence() {
        if (!this.app.settings.vadEnabled || !this.isCallActive) return;
        const visual = document.getElementById('audioVisualizer');
        const buffer = new Uint8Array(this.analyser.frequencyBinCount);
        const check = () => {
            if (!this.isCallActive) { visual.classList.remove('active'); return; }
            this.analyser.getByteFrequencyData(buffer);
            const vol = buffer.reduce((a,b) => a+b) / buffer.length / 128.0;
            visual.classList.toggle('active', vol > 0.1);

            if (this.isListening) {
                if (vol < this.config.vadThreshold) {
                    if (!this.silenceTimer) {
                        this.silenceTimer = setTimeout(() => this.stopListeningAndSend(), this.config.silenceDuration);
                    }
                } else {
                    clearTimeout(this.silenceTimer);
                    this.silenceTimer = null;
                    this.interrupt(); // User speaking can interrupt AI
                }
            }
            requestAnimationFrame(check);
        };
        check();
    }

    startListening() {
        if (!this.isCallActive || this.isListening || this.isSpeaking) return;
        this.isListening = true;
        document.getElementById('callStatus').innerText = "Listening...";
        const chunks = [];
        this.mediaRecorder = new MediaRecorder(this.stream, { mimeType: this.config.mimeType });
        this.mediaRecorder.ondataavailable = e => chunks.push(e.data);
        this.mediaRecorder.onstop = () => this.processAudio(new Blob(chunks, { type: this.config.mimeType }));
        this.mediaRecorder.start();
    }

    stopListeningAndSend() {
        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
            this.isListening = false;
            this.mediaRecorder.stop();
            document.getElementById('callStatus').innerText = "Processing...";
        }
    }

    async processAudio(blob) {
        if (blob.size < 1000) { if (this.isCallActive) this.startListening(); return; }
        let text = "";
        try {
            const { apiUrl, apiKey, sttUrl } = this.app.settings;
            if (!sttUrl) throw new Error("STT URL not configured in settings.");
            const formData = new FormData();
            formData.append('file', blob, 'audio.webm');
            formData.append('model', 'whisper-1'); // Model can be configured if needed
            const res = await fetch(apiUrl + sttUrl, { method: 'POST', headers: { 'Authorization': `Bearer ${apiKey}` }, body: formData });
            if (!res.ok) throw new Error(`STT API Error: ${res.statusText}`);
            text = (await res.json()).text;
        } catch (e) { text = `Error processing audio: ${e.message}`; }

        document.getElementById('liveTranscript').innerText = `You: "${text}"`;
        const response = await this.app.sendMessage(text, [], true);
        if (response && this.app.settings.handsFree) {
            await this.speak(response);
        }
        if (this.isCallActive && !this.isSpeaking) this.startListening();
    }

    async speak(text) {
        this.isSpeaking = true;
        document.getElementById('callStatus').innerText = "Speaking...";
        this.interruptController = new AbortController();
        try {
            const { ttsUrl, apiUrl, apiKey, playbackSpeed } = this.app.settings;
            if (ttsUrl) { // API based TTS
                const res = await fetch(apiUrl + ttsUrl, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model: "tts-1", input: text, voice: "alloy" }),
                    signal: this.interruptController.signal
                });
                if (!res.ok) throw new Error(`TTS API Error: ${res.statusText}`);
                const audioBlob = await res.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);
                audio.playbackRate = parseFloat(playbackSpeed);
                await audio.play();
                await new Promise(resolve => audio.onended = resolve);
            } else { // Browser native TTS
                await new Promise((resolve, reject) => {
                    if (this.interruptController.signal.aborted) return reject();
                    const u = new SpeechSynthesisUtterance(text);
                    u.rate = parseFloat(playbackSpeed);
                    u.onend = resolve;
                    u.onerror = reject;
                    window.speechSynthesis.speak(u);
                    this.interruptController.signal.addEventListener('abort', () => { window.speechSynthesis.cancel(); resolve(); });
                });
            }
        } catch(e) { console.error("TTS Error", e); }
        this.isSpeaking = false;
    }

    interrupt() {
        if (this.isSpeaking) {
            if (this.interruptController) this.interruptController.abort();
            window.speechSynthesis.cancel();
            this.isSpeaking = false;
            if (this.isCallActive) this.startListening();
        }
    }

    toggleMute() { 
        this.isMuted = !this.isMuted;
        this.stream.getAudioTracks()[0].enabled = !this.isMuted;
        document.getElementById('muteBtn').innerHTML = this.isMuted ? '<i class="fa-solid fa-microphone-slash"></i>' : '<i class="fa-solid fa-microphone"></i>';
    }
    toggleVideo() {
        const track = this.stream.getVideoTracks()[0];
        if(track) track.enabled = !track.enabled;
    }
}


// --- 3. Main App Logic ---
const app = {
    db: null, voice: null,
    settings: {
        apiProvider: 'ollama', apiUrl: 'http://localhost:11434', apiKey: '',
        sttUrl: '/v1/audio/transcriptions', ttsUrl: '/v1/audio/speech',
        webSearchApiKey: '', proxyMode: 'cors', customProxyUrl: '',
        chunkSize: 1000, chunkOverlap: 200, topK: 3,
        selectedModel: '', concurrentModel: '', 
        embeddingProvider: 'ollama', embeddingModel: '', embeddingBaseUrl: '', embeddingApiKey: '',
        enableHistory: true, vadEnabled: true, handsFree: true, emojiCall: false, playbackSpeed: 1.0
    },
    state: {
        isWebSearchEnabled: false, isConcurrent: false, isListening: false, recognition: null,
        docTriggerIndex: -1, chatListFilter: 'active', attachedImages: [], activeSpaceId: null,
        localPipeline: null, models: []
    },
    currentChat: { id: null, title: 'New Chat', messages: [], archived: false, updatedAt: Date.now(), spaceId: null },

    async init() {
        try {
            try {
                const saved = localStorage.getItem('superRagSettings');
                if (saved) this.settings = { ...this.settings, ...JSON.parse(saved) };
            } catch (e) {
                console.warn("Could not access localStorage. Using default settings.", e);
            }

            this.db = new VectorDB();
            try {
                await this.db.init();
            } catch (dbError) {
                console.error("IndexedDB initialization failed:", dbError);
                alert("Warning: Could not access browser storage (IndexedDB). Chat history and knowledge base are disabled.");
            }

            this.voice = new VoiceManager(this);

            this.loadSettingsUI();
            await this.checkConnection();
            await this.fetchModels();
            await this.updateStats();
            this.renderDocList();
            this.renderSpaces();
            this.setupInputHandling();
            this.setupLiveSearch();
            this.setupVoiceRecognition();
            
            this.renderChatList();
            this.newChat();

        } catch (e) { 
            document.body.innerHTML = `<div style='color:red; padding: 2rem;'>Fatal Initialization Error: ${e.message}.</div>`;
            console.error(e);
        }
    },

    loadSettingsUI() {
        Object.keys(this.settings).forEach(key => {
            const el = document.getElementById(key);
            if (el) {
                if (el.type === 'checkbox') el.checked = this.settings[key];
                else el.value = this.settings[key];
            }
        });
        
        this.toggleEmbeddingOptions();
        if (this.settings.embeddingProvider === 'openai') {
             document.getElementById('embeddingModelInput').value = this.settings.embeddingModel || '';
        }
        
        const speedEl = document.getElementById('speedVal');
        if (speedEl) speedEl.innerText = this.settings.playbackSpeed;
    },

    saveSettings() {
        Object.keys(this.settings).forEach(key => {
            const el = document.getElementById(key);
            if (el) {
                this.settings[key] = el.type === 'checkbox' ? el.checked : el.value;
            }
        });
        
        // Special handling for embedding model since UI varies
        if (this.settings.embeddingProvider === 'openai') {
            this.settings.embeddingModel = document.getElementById('embeddingModelInput').value;
        } else {
            this.settings.embeddingModel = document.getElementById('embeddingModelSelect').value;
        }

        localStorage.setItem('superRagSettings', JSON.stringify(this.settings));
        alert("Settings Saved");
        this.checkConnection();
        this.fetchModels();
    },
    
    // --- Navigation & UI ---
    switchTab(tabId) {
        document.querySelectorAll('.view').forEach(el => el.classList.remove('active'));
        document.getElementById(`view-${tabId}`).classList.add('active');
        document.querySelectorAll('.nav-btn').forEach(el => el.classList.remove('active'));
        const btn = document.querySelector(`.nav-btn[onclick="app.switchTab('${tabId}')"]`);
        if(btn) btn.classList.add('active');
        if(tabId === 'workspace') this.renderSpaces();
    },

    toggleConcurrent() {
        this.state.isConcurrent = !this.state.isConcurrent;
        document.querySelector('.concurrent-opt').style.display = this.state.isConcurrent ? 'flex' : 'none';
        document.getElementById('concurrentToggle').classList.toggle('active');
    },

    toggleWebSearch() {
        this.state.isWebSearchEnabled = !this.state.isWebSearchEnabled;
        document.getElementById('webSearchToggle').classList.toggle('active');
    },

    toggleEmbeddingOptions() {
        const provider = document.getElementById('embeddingProvider').value;
        const customConfig = document.getElementById('embeddingCustomConfig');
        const select = document.getElementById('embeddingModelSelect');
        const input = document.getElementById('embeddingModelInput');
        
        if (provider === 'openai') {
            customConfig.style.display = 'block';
            select.style.display = 'none';
            input.style.display = 'block';
        } else {
            customConfig.style.display = 'none';
            select.style.display = 'block';
            input.style.display = 'none';
            this.populateEmbeddingModels();
        }
    },

    populateEmbeddingModels() {
        const provider = document.getElementById('embeddingProvider').value;
        const select = document.getElementById('embeddingModelSelect');
        select.innerHTML = '';
        
        if (provider === 'local') {
            const models = ['Xenova/all-MiniLM-L6-v2', 'Xenova/bge-small-en-v1.5', 'Xenova/all-distilroberta-v1'];
            models.forEach(m => {
                const opt = document.createElement('option');
                opt.value = m; opt.text = m;
                if(m === this.settings.embeddingModel) opt.selected = true;
                select.appendChild(opt);
            });
            if(!this.settings.embeddingModel && models.length) select.value = models[0];
        } else if (provider === 'ollama') {
            if (this.state.models.length > 0) {
                this.state.models.forEach(m => {
                    const opt = document.createElement('option');
                    opt.value = m; opt.text = m;
                    if(m === this.settings.embeddingModel) opt.selected = true;
                    select.appendChild(opt);
                });
                // Try to find auto match if empty
                if (!this.settings.embeddingModel) {
                    const embed = this.state.models.find(m => m.includes('embed'));
                    if (embed) select.value = embed;
                }
            } else {
                select.innerHTML = '<option disabled>No Models Found</option>';
            }
        }
    },

    updateSpaceIndicator(name) {
        const el = document.getElementById('activeSpaceIndicator');
        if(!el) return;
        if(name) {
            el.style.display = 'inline-flex';
            el.innerHTML = `<i class="fa-solid fa-rocket"></i> ${name}`;
        } else {
            el.style.display = 'none';
        }
    },

    // --- Chat Management ---
    async newChat() {
        // Reset to global chat if we are not specifically in a space view
        const spaceId = (document.getElementById('view-space') && document.getElementById('view-space').classList.contains('active')) ? this.state.activeSpaceId : null;
        
        this.currentChat = { 
            id: crypto.randomUUID(), 
            title: 'New Chat', 
            messages: [], 
            archived: false, 
            updatedAt: Date.now(),
            spaceId: spaceId
        };
        
        document.getElementById('chatHistory').innerHTML = '<div class="message system"><div class="content"><p>ðŸ‘‹ Welcome to Shinzo UI, How can I assist you today?</p></div></div>';
        this.renderChatList();
        
        if(spaceId) {
             const space = await this.db.getSpace(spaceId);
             this.updateSpaceIndicator(space ? space.title : 'Space');
        } else {
             this.updateSpaceIndicator(null);
             this.switchTab('chat');
        }
    },

    async loadChat(id) {
        const chat = await this.db.idbTx('conversations', 'readonly', s => s.get(id));
        if (chat) {
            this.currentChat = chat;
            const hist = document.getElementById('chatHistory');
            hist.innerHTML = '';
            chat.messages.forEach(msg => {
                if(msg.role === 'user') this.appendMessageUI('user', msg.content, msg.images);
                else this.appendAIMessageUI(msg.content);
            });
            
            if (chat.spaceId) {
                this.state.activeSpaceId = chat.spaceId;
                const space = await this.db.getSpace(chat.spaceId);
                this.updateSpaceIndicator(space ? space.title : 'Unknown Space');
            } else {
                this.state.activeSpaceId = null;
                this.updateSpaceIndicator(null);
            }
            
            this.renderChatList();
            this.switchTab('chat');
        }
    },

    async saveCurrentChat() {
        if (!this.settings.enableHistory) return;
        if (this.currentChat.messages.length > 0 && this.currentChat.title === 'New Chat') {
            const firstMsg = this.currentChat.messages.find(m => m.role === 'user');
            if(firstMsg) this.currentChat.title = firstMsg.content.substring(0, 40) + '...';
        }
        this.currentChat.updatedAt = Date.now();
        await this.db.saveChat(this.currentChat);
        this.renderChatList();
    },

    async archiveCurrentChat() {
        this.currentChat.archived = !this.currentChat.archived;
        await this.saveCurrentChat();
        this.newChat();
    },

    async archiveAllChats() {
        if(!confirm("Archive ALL active chats?")) return;
        const chats = await this.db.getChats();
        for(let c of chats) { if(!c.archived) { c.archived = true; await this.db.saveChat(c); } }
        this.renderChatList();
    },

    async deleteAllChats() {
        if(!confirm("PERMANENTLY DELETE ALL CHATS? This cannot be undone.")) return;
        await this.db.deleteAllChats();
        this.newChat();
    },

    filterChatList(type) {
        this.state.chatListFilter = type;
        document.querySelectorAll('.chat-list-tabs button').forEach(b => b.classList.remove('active'));
        event.target.classList.add('active');
        this.renderChatList();
    },

    async renderChatList() {
        const chats = await this.db.getChats();
        // If in a space, only show chats for that space if we were in space view, 
        // but for main chat drawer, show all or let user filter? 
        // For simplicity: Sidebar shows all chats. Space view shows specific chats.
        const filtered = chats.filter(c => this.state.chatListFilter === 'active' ? !c.archived : c.archived);
        const list = document.getElementById('chatList');
        list.innerHTML = filtered.map(c => `
            <div class="chat-item ${this.currentChat.id === c.id ? 'active' : ''} ${c.spaceId ? 'space-chat' : ''}" onclick="app.loadChat('${c.id}')">
                <span>${c.spaceId ? '<i class="fa-solid fa-rocket" style="font-size:0.7em; margin-right:5px"></i>' : ''}${c.title || 'Untitled'}</span>
                <div class="item-actions">
                     <i class="fa-solid fa-trash" onclick="event.stopPropagation(); app.deleteSingleChat('${c.id}')"></i>
                </div>
            </div>`).join('');
    },

    async deleteSingleChat(id) {
        if(confirm("Delete this chat?")) {
            await this.db.deleteChat(id);
            if(this.currentChat.id === id) this.newChat();
            else this.renderChatList();
        }
    },

    // --- Messaging Logic ---
    async sendMessage(overrideText = null, overrideImages = [], isCall = false) {
        const input = document.getElementById('userInput');
        let text = overrideText || input.value.trim();
        let images = overrideImages.length > 0 ? overrideImages : this.state.attachedImages;
        if (!text && images.length === 0) return;

        this.settings.selectedModel = document.getElementById('modelSelect').value;
        if (!this.settings.selectedModel) { alert("Please select a primary model in settings."); return; }

        if (!isCall) {
            this.appendMessageUI('user', text, images);
            this.currentChat.messages.push({ role: 'user', content: text, images });
            await this.saveCurrentChat();
        }

        input.value = ''; input.style.height = 'auto'; this.state.attachedImages = [];

        const aiMessagePlaceholder = this.appendAIMessageUI("Thinking...");
        let finalResponseText = '';

        try {
            let context = ""; 
            let sources = [];
            let webSources = [];

            // 1. Check for Space Context
            let spaceInstructions = "";
            let spaceFilter = null;

            if (this.currentChat.spaceId) {
                const space = await this.db.getSpace(this.currentChat.spaceId);
                if (space) {
                    spaceInstructions = space.instructions || "";
                    spaceFilter = space.files || [];
                }
            }

            // 2. Web Search Logic
            if (this.state.isWebSearchEnabled || text.startsWith('web:')) {
                const query = text.startsWith('web:') ? text.substring(4) : text;
                const searchResults = await this.performWebSearch(query);
                context += `\nLIVE WEB SEARCH RESULTS for '${query}':\n` + searchResults.map(r => r.snippet).join('\n---\n');
                webSources = searchResults.map(r => ({ title: r.title, link: r.link }));
            }
            
            // 3. Vector Search Logic (Local RAG)
            // Only search if explicit toggle # or if we are in a space (default RAG context)
            if (text.includes('#') || (this.currentChat.spaceId && spaceFilter && spaceFilter.length > 0)) {
                const cleanText = text.replace('#', '');
                const emb = await this.getEmbedding(cleanText);
                const results = await this.db.vectorSearch(emb, parseInt(this.settings.topK), spaceFilter);
                context += "\nDOCUMENT CONTEXT:\n" + results.map(r => r.text).join('\n---\n');
                sources = results.map(r => ({ id: r.docId, text: r.text }));
            }

            // 4. Construct Prompt
            let systemPrompt = `You are a helpful AI assistant.`;
            if (spaceInstructions) systemPrompt += `\nIMPORTANT INSTRUCTIONS: ${spaceInstructions}`;
            if (context) systemPrompt += `\nUse the following context to answer the user's question:\n${context}`;
            if (this.settings.emojiCall && isCall) text += " (Please reply using only emojis if possible)";
            
            const history = this.currentChat.messages.slice(0, -1).map(m => ({ role: m.role, content: m.content }));
            const payload = {
                model: this.settings.selectedModel,
                messages: [...history, { role: 'system', content: systemPrompt }, { role: 'user', content: text, images }],
                stream: true
            };
            
            // 5. Fetch Stream
            const response = await fetch(`${this.settings.apiUrl}/api/chat`, { 
                method: 'POST', 
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${this.settings.apiKey}` },
                body: JSON.stringify(payload) 
            });

            if (!response.body) throw new Error("Response has no body.");
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let fullResponse = "";
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                const lines = decoder.decode(value, { stream: true }).split('\n');
                for (const line of lines) {
                    if (!line.trim()) continue;
                    try {
                        const json = JSON.parse(line);
                        if (json.message && json.message.content) {
                            fullResponse += json.message.content;
                            let renderedHTML = DOMPurify.sanitize(marked.parse(fullResponse));
                            if (sources.length > 0) renderedHTML = this.injectCitations(renderedHTML, sources);
                            aiMessagePlaceholder.innerHTML = renderedHTML;
                            if (typeof renderMathInElement === 'function') renderMathInElement(aiMessagePlaceholder);
                        }
                    } catch (e) { /* Ignore parsing errors */ }
                }
            }
            finalResponseText = fullResponse;

            // Append Sources Section if available
            if (webSources.length > 0) {
                const sourceHtml = `<div class="source-list"><strong>Sources:</strong><ul>` + 
                    webSources.map(s => `<li><a href="${s.link}" target="_blank">${s.title}</a></li>`).join('') + 
                    `</ul></div>`;
                aiMessagePlaceholder.insertAdjacentHTML('beforeend', sourceHtml);
                finalResponseText += "\n\n[Sources: " + webSources.map(s => s.link).join(', ') + "]";
            }

        } catch (e) {
            aiMessagePlaceholder.innerHTML = `Error: ${e.message}`;
            finalResponseText = `Error: ${e.message}`;
        }

        this.currentChat.messages.push({ role: 'ai', content: finalResponseText });
        await this.saveCurrentChat();
        return finalResponseText;
    },

    injectCitations(html, sources) {
        let count = 1;
        sources.forEach(source => {
            const citationTag = `<a class="citation" title="${source.text.substring(0,200)}...">[${count++}]</a>`;
            html = html.replace(/(\.\s|\.$)/, ` ${citationTag} `);
        });
        return html;
    },

    appendMessageUI(role, text, images = []) {
        const h = document.getElementById('chatHistory');
        const d = document.createElement('div');
        d.className = `message ${role}`;
        let imageHTML = '';
        if (images && images.length > 0) {
            const imageElements = images.map(img => `<img src="data:image/jpeg;base64,${img}" alt="attached image">`).join('');
            imageHTML = `<div class="image-attachment-container">${imageElements}</div>`;
        }
        
        // Copy Button and Tools
        const toolsHTML = `
            <div class="message-tools">
                <button onclick="app.copyToClipboard(this)" title="Copy"><i class="fa-regular fa-copy"></i></button>
            </div>
        `;

        d.innerHTML = `
            <div class="avatar"><i class="fa-solid fa-${role === 'user' ? 'user' : 'robot'}"></i></div>
            <div class="content">${DOMPurify.sanitize(marked.parse(text))}${imageHTML}</div>
            ${toolsHTML}
        `;
        h.appendChild(d);
        h.scrollTop = h.scrollHeight;
    },

    appendAIMessageUI(content) {
        const h = document.getElementById('chatHistory');
        const d = document.createElement('div');
        d.className = 'message ai';
        const toolsHTML = `
            <div class="message-tools">
                <button onclick="app.copyToClipboard(this)" title="Copy"><i class="fa-regular fa-copy"></i></button>
            </div>
        `;
        d.innerHTML = `
            <div class="avatar"><i class="fa-solid fa-robot"></i></div>
            <div class="content">${DOMPurify.sanitize(marked.parse(content))}</div>
            ${toolsHTML}
        `;
        h.appendChild(d);
        h.scrollTop = h.scrollHeight;
        return d.querySelector('.content');
    },

    copyToClipboard(btn) {
        const content = btn.closest('.message').querySelector('.content').innerText;
        navigator.clipboard.writeText(content).then(() => {
            const original = btn.innerHTML;
            btn.innerHTML = '<i class="fa-solid fa-check"></i>';
            setTimeout(() => btn.innerHTML = original, 1500);
        });
    },

    // --- Knowledge & RAG ---
    async handleFileUpload(input) { this.processFiles(input.files); input.value = ''; },
    
    async processFiles(files) {
        if (!files.length) return;
        document.getElementById('uploadProgress').style.display = 'block';
        try {
            for (let file of files) {
                document.getElementById('uploadStatusText').innerText = `Processing ${file.name}...`;
                let text = await this.extractTextFromFile(file);
                if (!text || text.trim().length === 0) {
                    console.warn(`No text extracted from ${file.name}`);
                    continue;
                }
                const docId = `${file.name}-${Date.now()}`;
                await this.db.addDocument({ id: docId, name: file.name, type: file.type });
                
                const size = parseInt(this.settings.chunkSize) || 1000;
                const overlap = parseInt(this.settings.chunkOverlap) || 200;
                const chunks = this.createChunks(text, size, overlap);
                
                const chunkObjs = [];
                for (let i = 0; i < chunks.length; i++) {
                    const vec = await this.getEmbedding(chunks[i]);
                    chunkObjs.push({ id: `${docId}_${i}`, docId, text: chunks[i], vector: vec });
                }
                await this.db.addChunks(chunkObjs);
            }
        } catch(e) {
            alert(`Upload failed: ${e.message}`);
            console.error(e);
        }
        document.getElementById('uploadProgress').style.display = 'none';
        this.updateStats();
        this.renderDocList();
    },

    async extractTextFromFile(file) {
        const isPdf = file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf');
        const isDocx = file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || file.name.toLowerCase().endsWith('.docx');

        if (isPdf) {
            const ab = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: ab }).promise;
            let txt = "";
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const content = await page.getTextContent();
                txt += content.items.map(s => s.str).join(' ');
            }
            return txt;
        } else if (isDocx && window.mammoth) {
            const ab = await file.arrayBuffer();
            const result = await mammoth.extractRawText({ arrayBuffer: ab });
            return result.value;
        }
        return file.text();
    },

    createChunks(text, size, overlap) {
        if (!size || size < 100) size = 1000;
        if (!overlap || overlap < 0) overlap = 100;
        if (size <= overlap) overlap = Math.floor(size / 2);
        
        const chunks = [];
        for (let i = 0; i < text.length; i += (size - overlap)) {
            chunks.push(text.slice(i, i + size));
        }
        return chunks;
    },

    async updateStats() {
        const docs = await this.db.getAllDocuments();
        const vectors = await this.db.getVectorCount();
        const dc = document.getElementById('docCount');
        const vc = document.getElementById('vectorCount');
        if(dc) dc.innerText = docs.length;
        if(vc) vc.innerText = vectors;
    },

    async renderDocList() {
        const docs = await this.db.getAllDocuments();
        const tbody = document.getElementById('docTableBody');
        if (tbody) tbody.innerHTML = docs.map(d => `<tr><td>${d.name}</td><td>${d.type}</td><td>-</td><td><button class="delete-doc-btn" onclick="app.deleteDoc('${d.id}')"><i class="fa-solid fa-trash"></i></button></td></tr>`).join('');
    },

    async deleteDoc(id) { if(confirm("Delete document?")) { await this.db.deleteDocument(id); this.updateStats(); this.renderDocList(); }},
    async clearDatabase() { if(confirm("Reset entire database?")) { await this.db.clear(); this.updateStats(); this.renderDocList(); this.newChat(); this.renderSpaces(); }},

    // --- Workspace (Spaces) Logic ---
    openSpaceModal() {
        document.getElementById('spaceModal').style.display = 'flex';
    },

    async saveNewSpace() {
        const title = document.getElementById('newSpaceTitle').value;
        if(!title) return alert("Title is required");
        const desc = document.getElementById('newSpaceDesc').value;
        const prompt = document.getElementById('newSpacePrompt').value;

        const space = {
            id: crypto.randomUUID(),
            title,
            description: desc,
            instructions: prompt,
            files: [],
            links: [],
            updatedAt: Date.now()
        };
        await this.db.saveSpace(space);
        document.getElementById('spaceModal').style.display = 'none';
        this.renderSpaces();
    },

    async renderSpaces() {
        const spaces = await this.db.getSpaces();
        const grid = document.getElementById('spacesGrid');
        if(grid) grid.innerHTML = spaces.map(s => `
            <div class="collection-card" onclick="app.openSpace('${s.id}')">
                <h3>${s.title}</h3>
                <p>${s.description || 'No description'}</p>
                <div class="collection-footer">
                    <span>${new Date(s.updatedAt).toLocaleDateString()}</span>
                </div>
            </div>
        `).join('') || '<p>No spaces created yet.</p>';
    },

    async openSpace(id) {
        this.state.activeSpaceId = id;
        const space = await this.db.getSpace(id);
        if(!space) return;
        
        this.switchTab('space');
        document.getElementById('spaceTitleDisplay').innerText = space.title;
        document.getElementById('spaceInstructions').value = space.instructions || '';
        
        // Render Files
        const allDocs = await this.db.getAllDocuments();
        const spaceFiles = allDocs.filter(d => space.files.includes(d.id));
        document.getElementById('spaceFileList').innerHTML = spaceFiles.map(f => 
            `<div class="space-item"><i class="fa-solid fa-file"></i> ${f.name} <i class="fa-solid fa-xmark remove" onclick="app.removeFileFromSpace('${f.id}')"></i></div>`
        ).join('');

        // Render Links
        document.getElementById('spaceLinkList').innerHTML = space.links.map((l, i) => 
            `<div class="space-item"><i class="fa-solid fa-link"></i> <a href="${l}" target="_blank">${l}</a> <i class="fa-solid fa-xmark remove" onclick="app.removeLinkFromSpace(${i})"></i></div>`
        ).join('');

        // Render Chats
        const chats = await this.db.getChats();
        const spaceChats = chats.filter(c => c.spaceId === id);
        document.getElementById('spaceChatList').innerHTML = spaceChats.map(c => 
            `<div class="chat-item" onclick="app.loadChat('${c.id}')"><span>${c.title}</span> <small>${new Date(c.updatedAt).toLocaleDateString()}</small></div>`
        ).join('');
    },

    async updateSpaceConfig() {
        if(!this.state.activeSpaceId) return;
        const space = await this.db.getSpace(this.state.activeSpaceId);
        space.instructions = document.getElementById('spaceInstructions').value;
        space.updatedAt = Date.now();
        await this.db.saveSpace(space);
    },

    async handleSpaceFileUpload(input) {
        if(!this.state.activeSpaceId) return;
        await this.processFiles(input.files);
        // After upload, assume user wants to add them to this space. 
        // Current implementation of processFiles adds to global docs. 
        // We need to link the newly added doc IDs to this space. 
        // For simplicity, let's just find the docs that match names. 
        // Ideally, processFiles should return IDs.
        // Simpler approach for now: Just scan DB for recently added or just added.
        // Let's refine: We will re-fetch docs and match by name for this demo.
        const allDocs = await this.db.getAllDocuments();
        const space = await this.db.getSpace(this.state.activeSpaceId);
        
        for (let file of input.files) {
            const match = allDocs.find(d => d.name === file.name); // Simple match
            if(match && !space.files.includes(match.id)) {
                space.files.push(match.id);
            }
        }
        await this.db.saveSpace(space);
        this.openSpace(this.state.activeSpaceId);
    },

    async removeFileFromSpace(docId) {
        const space = await this.db.getSpace(this.state.activeSpaceId);
        space.files = space.files.filter(id => id !== docId);
        await this.db.saveSpace(space);
        this.openSpace(this.state.activeSpaceId);
    },

    async addLinkToSpace() {
        const url = document.getElementById('newSpaceLink').value;
        if(!url) return;
        const space = await this.db.getSpace(this.state.activeSpaceId);
        space.links.push(url);
        await this.db.saveSpace(space);
        document.getElementById('newSpaceLink').value = '';
        this.openSpace(this.state.activeSpaceId);
    },

    async removeLinkFromSpace(index) {
        const space = await this.db.getSpace(this.state.activeSpaceId);
        space.links.splice(index, 1);
        await this.db.saveSpace(space);
        this.openSpace(this.state.activeSpaceId);
    },

    newChatInSpace() {
        this.newChat();
        this.currentChat.spaceId = this.state.activeSpaceId;
        this.saveCurrentChat();
        this.switchTab('chat');
    },

    async deleteCurrentSpace() {
        if(confirm("Delete this space? Chats will remain but unlink.")) {
            await this.db.deleteSpace(this.state.activeSpaceId);
            this.switchTab('workspace');
        }
    },

    // --- Live Search ---
    setupLiveSearch() {
        const input = document.getElementById('liveSearchInput');
        const resultsDiv = document.getElementById('searchResults');
        let debounceTimer;
        input.addEventListener('input', () => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(async () => {
                const query = input.value.trim();
                if (query.length < 3) {
                    resultsDiv.style.display = 'none';
                    return;
                }
                resultsDiv.innerHTML = '';
                resultsDiv.style.display = 'block';
                
                let results = [];
                if (query.startsWith('web:')) {
                    const raw = await this.performWebSearch(query.substring(4));
                    results = raw.map(r => ({
                        html: `<div class="search-result-item" onclick="app.newChatAndSend('Summarize: ${r.title}')"><i class="fa-solid fa-globe"></i> ${r.title}</div>`
                    }));
                } else {
                    results = await this.performLocalSearch(query);
                }

                resultsDiv.innerHTML = results.length > 0 ? results.map(r => r.html).join('') : '<div class="search-result-item">No results found</div>';
            }, 300);
        });
        document.addEventListener('click', (e) => { if (!input.contains(e.target)) resultsDiv.style.display = 'none'; });
    },

    async performWebSearch(query) {
        const { webSearchApiKey, proxyMode, customProxyUrl } = this.settings;
        // Returns array of { title, link, snippet }
        
        // 1. Serper API
        if (webSearchApiKey) {
            try {
                const response = await fetch('https://google.serper.dev/search', {
                    method: 'POST',
                    headers: { 'X-API-KEY': webSearchApiKey, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ q: query })
                });
                const data = await response.json();
                return (data.organic || []).slice(0, 5).map(item => ({
                    title: item.title,
                    link: item.link,
                    snippet: `[${item.title}](${item.link}): ${item.snippet}`
                }));
            } catch (e) { console.error("Serper Error", e); }
        }

        // 2. Scrape Fallback
        try {
            const targetUrl = `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}`;
            let fetchUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(targetUrl)}`;
            if (proxyMode === 'custom') fetchUrl = customProxyUrl + encodeURIComponent(targetUrl);
            
            const res = await fetch(fetchUrl);
            const html = await res.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const results = [];
            doc.querySelectorAll('.result').forEach((node, index) => {
                if (index >= 5) return;
                const titleNode = node.querySelector('.result__a');
                const snippetNode = node.querySelector('.result__snippet');
                if (titleNode && snippetNode) {
                    results.push({
                        title: titleNode.innerText.trim(),
                        link: titleNode.href,
                        snippet: `Title: ${titleNode.innerText.trim()}\nLink: ${titleNode.href}\nSummary: ${snippetNode.innerText.trim()}`
                    });
                }
            });
            if (results.length > 0) return results;
            throw new Error("No results parsed");
        } catch (e) {
             // 3. API Fallback
             try {
                const fallbackUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(`https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json`)}`;
                const res = await fetch(fallbackUrl);
                const data = await res.json();
                return (data.RelatedTopics || []).slice(0, 5).filter(i => i.Text).map(i => ({
                    title: i.Text.split('-')[0],
                    link: i.FirstURL || '#',
                    snippet: i.Text
                }));
            } catch (err) { return []; }
        }
    },

    async performLocalSearch(query) {
        const chats = await this.db.getChats();
        const docs = await this.db.getAllDocuments();
        let results = [];
        chats.filter(c => c.title.toLowerCase().includes(query.toLowerCase())).forEach(c => {
            results.push({ html: `<div class="search-result-item" onclick="app.loadChat('${c.id}')"><i class="fa-solid fa-comments"></i> Chat: ${c.title}</div>` });
        });
        docs.filter(d => d.name.toLowerCase().includes(query.toLowerCase())).forEach(d => {
            results.push({ html: `<div class="search-result-item" onclick="app.newChatAndSend('Tell me about document #${d.name}')"><i class="fa-solid fa-file-lines"></i> Doc: ${d.name}</div>` });
        });
        return results.slice(0, 10);
    },

    newChatAndSend(prompt) {
        this.newChat();
        document.getElementById('userInput').value = prompt;
        this.sendMessage();
    },

    // --- Utilities ---
    setupInputHandling() {
        const input = document.getElementById('userInput');
        input.addEventListener('input', () => {
            input.style.height = 'auto';
            input.style.height = (input.scrollHeight) + 'px';
        });
        // Enter key shortcut
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.sendMessage();
            }
        });
    },

    async handleFileAttach(input) {
        const file = input.files[0];
        if (!file || !file.type.startsWith('image/')) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            const base64 = e.target.result.split(',')[1];
            this.state.attachedImages.push(base64);
            alert(`Image ${file.name} attached. Ready to send.`);
        }
        reader.readAsDataURL(file);
    },

    setupVoiceRecognition() {
        if ('webkitSpeechRecognition' in window) {
            const SR = window.webkitSpeechRecognition;
            this.state.recognition = new SR();
            this.state.recognition.continuous = false;
            this.state.recognition.interimResults = false;
            this.state.recognition.onresult = (e) => {
                document.getElementById('userInput').value += e.results[0][0].transcript + ' ';
                this.toggleVoice();
            };
        }
    },

    toggleVoice() {
        if(!this.state.recognition) return alert('Speech recognition not supported in this browser.');
        const btn = document.getElementById('voiceBtn');
        if (this.state.isListening) {
            this.state.recognition.stop();
            btn.classList.remove('listening');
        } else {
            this.state.recognition.start();
            btn.classList.add('listening');
        }
        this.state.isListening = !this.state.isListening;
    },

    async checkConnection() {
        const statusText = document.getElementById('statusText');
        const indicator = document.querySelector('#connectionStatus .indicator');
        try {
            await fetch(this.settings.apiUrl);
            statusText.innerText = 'Connected';
            indicator.classList.add('connected');
        } catch (e) {
            statusText.innerText = 'Connection Failed';
            indicator.classList.remove('connected');
        }
    },

    async fetchModels() {
        try {
            const res = await fetch(`${this.settings.apiUrl}/api/tags`);
            const data = await res.json();
            const models = (data.models || []).map(m => m.name || m.model);
            this.state.models = models;
            
            // Auto-select logic
            if (!this.settings.selectedModel || !models.includes(this.settings.selectedModel)) {
                this.settings.selectedModel = models[0] || '';
            }

            const populate = (id, selected) => {
                const sel = document.getElementById(id);
                if (!sel) return;
                sel.innerHTML = models.length ? '' : '<option value="" disabled selected>No Models Found</option>';
                models.forEach(m => {
                    const isSelected = m === selected;
                    sel.innerHTML += `<option value="${m}" ${isSelected ? 'selected' : ''}>${m}</option>`;
                });
                if (!selected && models.length > 0) sel.value = models[0];
            };

            populate('modelSelect', this.settings.selectedModel);
            populate('modelSelect2', this.settings.concurrentModel);
            populate('builderBaseModel');
            
            // Populate embedding models logic
            this.populateEmbeddingModels();

        } catch (e) { console.error("Failed to fetch models", e); }
    },

    async getEmbedding(text) {
        const provider = this.settings.embeddingProvider || 'ollama';
        const model = this.settings.embeddingModel;

        if (provider === 'local') {
            // Lazy load pipeline
            if (!this.state.localPipeline) {
                // Dynamic import transformers.js from CDN
                try {
                   const { pipeline, env } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.16.0/dist/transformers.min.js');
                   env.allowLocalModels = false;
                   this.state.localPipeline = await pipeline('feature-extraction', model);
                } catch(e) {
                   throw new Error("Failed to load local embedding model: " + e.message);
                }
            }
            const output = await this.state.localPipeline(text, { pooling: 'mean', normalize: true });
            return Array.from(output.data);
        } 
        
        if (provider === 'openai') {
            const url = this.settings.embeddingBaseUrl || 'https://api.openai.com/v1/embeddings';
            const key = this.settings.embeddingApiKey;
            if(!key) throw new Error("API Key required for custom embedding provider");
            
            const res = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${key}`
                },
                body: JSON.stringify({ model: model || 'text-embedding-3-small', input: text })
            });
            if(!res.ok) {
                let msg = res.statusText;
                try { msg = (await res.json()).error.message; } catch(e){}
                throw new Error("Embedding API Error: " + msg);
            }
            const json = await res.json();
            return json.data[0].embedding;
        }

        // Default Ollama
        if (!model) throw new Error("Embedding model not selected in settings.");
        const cleanText = text.replace(/\n/g, " ");

        const res = await fetch(`${this.settings.apiUrl}/api/embeddings`, {
            method: 'POST', 
            headers: { 
                'Content-Type': 'application/json', 
                'Authorization': `Bearer ${this.settings.apiKey}` 
            },
            body: JSON.stringify({ model: model, prompt: cleanText })
        });
        
        if(!res.ok) {
            let errorMsg = res.statusText;
            try { 
                const json = await res.json();
                errorMsg = json.error || JSON.stringify(json);
            } catch(e) { 
                try { errorMsg = await res.text(); } catch(z){} 
            }
            throw new Error(`Embedding API failed (${res.status}): ${errorMsg}`);
        }
        return (await res.json()).embedding;
    },

    async buildModel() {
        const name = document.getElementById('builderName').value;
        const base = document.getElementById('builderBaseModel').value;
        const prompt = document.getElementById('builderPrompt').value;
        const params = document.getElementById('builderParams').value;
        if (!name || !base) return alert('Name and base model are required.');
        let modelfile = `FROM ${base}\nSYSTEM ${prompt}`;
        if(params) modelfile += `\n${params}`;
        alert('Creating model... check your Ollama server logs.');
        await fetch(`${this.settings.apiUrl}/api/create`, { method: 'POST', body: JSON.stringify({ name, modelfile }) });
        await this.fetchModels();
    },
    
    triggerImport() { document.getElementById('importChatInput').click(); },
    exportChats() { alert('Export not implemented in this version.'); },
    importChats() { alert('Import not implemented in this version.'); },
    downloadChat() { alert('Download not implemented in this version.'); }
};

window.addEventListener('DOMContentLoaded', () => app.init());
document.getElementById('spaceModal').addEventListener('click', (e) => { if(e.target.id === 'spaceModal') e.target.style.display='none'; });</script></body></html>